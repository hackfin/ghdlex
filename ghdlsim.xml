<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="/home/strubi/src/netpp/xml/devdesc.css"?>
<devdesc version="0.1"
         xsi:schemaLocation="http://www.section5.ch/dclib/schema/devdesc /home/strubi/src/netpp/xml/devdesc.xsd"
         xmlns="http://www.section5.ch/dclib/schema/devdesc"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns3="http://www.xmlmind.com/xmleditor/schema/bugreport"
         xmlns:ns2="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://www.section5.ch/dclib/schema/devdesc"
         xmlns:interfaces="http://www.section5.ch/dclib/schema/interfaces"
         xmlns:html="http://www.xmlmind.com/xmleditor/schema/xhtml"
         xmlns:hfp="http://www.w3.org/2001/XMLSchema-hasFacetAndProperty">
  <vendor>section5</vendor>

  <!--// (c) 01/2007, Martin Strubel
// $Id: example.xml 309 2011-05-12 12:42:54Z strubi $
-->

  <revision>
    <major>0</major>

    <minor>1</minor>

    <extension>develop</extension>
  </revision>

  <header language="C">#include "example.h"</header>

  <header language="VHDL">-- library work; use work.iomap_config.all;</header>

  <!--This is a header file specification. Statements in this field will be included
in handler skeleton code and in the generated property list.
Including a header is necessary when implementing access to global variables.-->

  <returncodes>
    <errorspec code="-1024" name="STREAM_START">
      <info>Could not start stream (File I/O error)</info>
    </errorspec>

    <errorspec name="CAPTURE_START">
      <info>Could not start capture</info>
    </errorspec>

    <errorspec name="CAPTURE_STOP">
      <info>Could not stop capture</info>
    </errorspec>

    <errorspec name="VIDEO_QUEUE">
      <info>Video buffer queue error</info>
    </errorspec>

    <errorspec name="VIDEO_TIMEOUT">
      <info>Video frame timeout</info>
    </errorspec>

    <errorspec name="VIDEO_POLL">
      <info>Failed when polling for frame</info>
    </errorspec>

    <errorspec name="CAPTURE_STATUS">
      <info>Could not get capture status</info>
    </errorspec>

    <errorspec name="STREAM_WRITE">
      <info>Could not write stream (File I/O error)</info>
    </errorspec>

    <errorspec name="VIDEODEVICE_OPEN">
      <info>Could not open video device</info>
    </errorspec>

    <errorspec name="VIDEOBUF_ALLOC">
      <info>Could not allocate video buffers</info>
    </errorspec>

    <errorspec name="VIDEOBUF_MMAP">
      <info>Failed to mmap() video buffer</info>
    </errorspec>

    <errorspec name="VIDEOFORMAT">
      <info>Could not set video format</info>
    </errorspec>

    <errorspec name="STATE">
      <info>Bad machine state. Your code has a bug!</info>
    </errorspec>

    <errorspec name="I2C">
      <info>Could not access i2c bus</info>
    </errorspec>
  </returncodes>

  <device id="ghdlsim" name="GHDLSimInterface" protocol="PROPERTY">
    <revision>
      <major>0</major>

      <minor>0</minor>
    </revision>

    <!--A (virtual) register map:-->

    <registermap addrsize="16" endian="LITTLE" hidden="true" id="fake"
                 name="Fake MMR">
      <register access="RO" addr="0x00" id="decode_dummy">
        <bitfield lsb="0" msb="6" name="MMR_CFG_fpga_registers"></bitfield>

        <bitfield lsb="0" msb="4" name="MMR_CFG_tap_registers"></bitfield>
      </register>
    </registermap>

    <registermap addrsize="16" endian="BIG" id="fpga_registers"
                 name="FPGA_Registers" offset="0x000">
      <register access="RO" addr="0x00" id="MagicId"></register>

      <register addr="0x02" id="Control">
        <info>Control register</info>

        <bitfield lsb="0" msb="0" name="ENABLE">
          <info>Enable FPGA engine</info>
        </bitfield>

        <bitfield lsb="1" msb="1" name="THROTTLE">
          <info>If set, slow down simulation</info>
        </bitfield>

        <bitfield lsb="6" msb="6" name="IRQ">
          <info>Virtual IRQ pin, H active</info>
        </bitfield>

        <bitfield lsb="7" msb="7" name="RESET">
          <info>RESET FPGA engine</info>
        </bitfield>
      </register>
    </registermap>

    <registermap addrsize="4" endian="BIG" id="tap_registers" name="TAP"
                 offset="0x0200">
      <register access="RO" addr="0x00" id="TAP_IDCODE" size="4"></register>

      <register access="RO" addr="0x04" id="TAP_EMUDATA" size="4"></register>

      <register addr="0x08" id="TAP_EMUCTRL" size="2">
        <bitfield lsb="0" msb="0" name="EMUREQ"></bitfield>

        <bitfield lsb="4" msb="6" name="SELECT_REG"></bitfield>

        <bitfield lsb="7" msb="7" name="EMUEXEC"></bitfield>

        <bitfield lsb="15" msb="15" name="CORE_RESET"></bitfield>

        <default>0000000000000000</default>
      </register>

      <register access="RO" addr="0x0a" id="TAP_EMUSTAT" size="2">
        <bitfield lsb="0" msb="0" name="EMUACK"></bitfield>

        <bitfield lsb="1" msb="1" name="EMURDY"></bitfield>

        <bitfield lsb="8" msb="15" name="CORE_SPEC"></bitfield>
      </register>

      <register access="RW" addr="0x0c" id="TAP_EMUIR" size="4"></register>

      <register access="RO" addr="0x10" id="TAP_EMUPC" size="4"></register>

      <register access="RW" addr="0x18" id="TAP_SIMCTRL" size="1">
        <bitfield lsb="0" msb="0" name="SIM_THROTTLE"></bitfield>

        <default>1</default>
      </register>
    </registermap>

    <group name="VirtualTap">
      <info>The VirtualTAP register set is a direct test access port implemented as virtual Bus in GHDLex.
It does not require any extra handshake logic.</info>

      <property name="EmuExec" type="BOOL">
        <info>Toggle this pin to execute command in EmuIR register</info>

        <regref bits="EMUEXEC" ref="TAP_EMUCTRL" />
      </property>

      <property name="EmuReq" type="BOOL">
        <info>Setting this bit H asserts the emulation request pin to the core</info>

        <regref bits="EMUREQ" ref="TAP_EMUCTRL" />
      </property>

      <property name="SimThrottle" type="BOOL">
        <info>Set 1 to throttle simulation</info>

        <regref bits="SIM_THROTTLE" ref="TAP_SIMCTRL" />
      </property>

      <property access="RO" name="EmuReady" type="BOOL">
        <info>'1' when emulation ready</info>

        <regref bits="EMURDY" ref="TAP_EMUSTAT" />
      </property>

      <property access="RO" name="EmuAck" type="BOOL">
        <info>'1' when in emulation mode</info>

        <regref bits="EMUACK" ref="TAP_EMUSTAT" />
      </property>

      <property access="RO" name="EmuStat" type="REGISTER">
        <info>Emulation status register</info>

        <regref ref="TAP_EMUSTAT" />
      </property>

      <property name="EmuCtrl" type="REGISTER">
        <info>Emulation control register</info>

        <regref ref="TAP_EMUCTRL" />
      </property>

      <property name="EmuIR" type="REGISTER">
        <info>Instruction to execute on core on next EmuExec bit toggle</info>

        <regref ref="TAP_EMUIR" />
      </property>

      <property access="RO" name="EmuData" type="REGISTER">
        <info>Return emulation data from the core</info>

        <regref ref="TAP_EMUDATA" />
      </property>

      <property access="RO" name="EmuPC" type="REGISTER">
        <info>Current Program counter of core. Valid only when in emulation.</info>

        <regref ref="TAP_EMUPC" />
      </property>

      <property access="RO" name="IDCode" type="REGISTER">
        <info>The IDCODE of the core. Unique to every core architecture.</info>

        <regref ref="TAP_IDCODE" />
      </property>
    </group>

    <group name="VirtualPins">
      <property access="RW" name="Enable" type="BOOL">
        <info>Enable bit. Might be not used.</info>

        <regref bits="ENABLE" ref="Control" />
      </property>

      <property access="RW" name="Reset" type="BOOL">
        <info>External reset pin. High active.</info>

        <regref bits="RESET" ref="Control" />
      </property>

      <property access="RW" name="Timeout" type="INT">
        <info>Timeout value of FIFO in real microseconds</info>

        <variable>g_fifoconfig.timeout</variable>
      </property>

      <property access="RW" name="Retry" type="INT">
        <info>Number of retries after timeout</info>

        <variable>g_fifoconfig.retry</variable>
      </property>

      <property access="RW" name="Throttle" type="BOOL">
        <info>Throttle bit. If set, simulation will sleep (therefore run slower) while there is no FIFO activity</info>

        <regref bits="THROTTLE" ref="Control" />
      </property>

      <property access="RW" name="Irq" type="BOOL">
        <info>Simulates an IRQ pin. High active. Might not be implemented in all cores.</info>

        <regref bits="IRQ" ref="Control" />
      </property>
    </group>

    <group name="VirtualJTAG">
      <struct id="fifo" name="Fifo">
        <property access="RW" id="fifobuf" name="Buffer" type="BUFFER">
          <!--A buffer object that is handled via a handler function. See handler.c
(Function get_fifo()/set_fifo() for details.)-->

          <info>A FIFO buffer for communication between VHDL simulation and external software.</info>

          <handler type="DYNAMIC">fifo</handler>
        </property>

        <property access="RO" id="fifo_infill" name="InFill" type="INT">
          <handler type="DYNAMIC">fifo_infill</handler>
        </property>

        <property access="RO" id="fifo_outfill" name="OutFill" type="INT">
          <handler type="DYNAMIC">fifo_outfill</handler>
        </property>
      </struct>
    </group>
  </device>
</devdesc>
