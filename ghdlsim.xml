<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="/home/strubi/src/netpp/xml/devdesc.css"?>
<devdesc version="0.1"
         xsi:schemaLocation="http://www.section5.ch/dclib/schema/devdesc /home/strubi/src/netpp/xml/devdesc.xsd"
         xmlns="http://www.section5.ch/dclib/schema/devdesc"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns3="http://www.xmlmind.com/xmleditor/schema/bugreport"
         xmlns:ns2="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://www.section5.ch/dclib/schema/devdesc"
         xmlns:interfaces="http://www.section5.ch/dclib/schema/interfaces"
         xmlns:html="http://www.xmlmind.com/xmleditor/schema/xhtml"
         xmlns:hfp="http://www.w3.org/2001/XMLSchema-hasFacetAndProperty">
  <vendor>section5</vendor>

  <!--// (c) 01/2007, Martin Strubel
// $Id: example.xml 309 2011-05-12 12:42:54Z strubi $
-->

  <revision>
    <major>0</major>

    <minor>1</minor>

    <extension>develop</extension>
  </revision>

  <header language="C">#include "example.h"</header>

  <header language="VHDL">library work; use work.iomap_config.all;</header>

  <!--This is a header file specification. Statements in this field will be included
in handler skeleton code and in the generated property list.
Including a header is necessary when implementing access to global variables.-->

  <returncodes>
    <errorspec code="-1024" name="STREAM_START">
      <info>Could not start stream (File I/O error)</info>
    </errorspec>

    <errorspec name="CAPTURE_START">
      <info>Could not start capture</info>
    </errorspec>

    <errorspec name="CAPTURE_STOP">
      <info>Could not stop capture</info>
    </errorspec>

    <errorspec name="VIDEO_QUEUE">
      <info>Video buffer queue error</info>
    </errorspec>

    <errorspec name="VIDEO_TIMEOUT">
      <info>Video frame timeout</info>
    </errorspec>

    <errorspec name="VIDEO_POLL">
      <info>Failed when polling for frame</info>
    </errorspec>

    <errorspec name="CAPTURE_STATUS">
      <info>Could not get capture status</info>
    </errorspec>

    <errorspec name="STREAM_WRITE">
      <info>Could not write stream (File I/O error)</info>
    </errorspec>

    <errorspec name="VIDEODEVICE_OPEN">
      <info>Could not open video device</info>
    </errorspec>

    <errorspec name="VIDEOBUF_ALLOC">
      <info>Could not allocate video buffers</info>
    </errorspec>

    <errorspec name="VIDEOBUF_MMAP">
      <info>Failed to mmap() video buffer</info>
    </errorspec>

    <errorspec name="VIDEOFORMAT">
      <info>Could not set video format</info>
    </errorspec>

    <errorspec name="STATE">
      <info>Bad machine state. Your code has a bug!</info>
    </errorspec>

    <errorspec name="I2C">
      <info>Could not access i2c bus</info>
    </errorspec>
  </returncodes>

  <device id="ghdlsim" name="GHDLSimInterface" protocol="PROPERTY">
    <revision>
      <major>0</major>

      <minor>0</minor>
    </revision>

    <!--A (virtual) register map:-->

    <registermap addrsize="16" endian="LITTLE" hidden="true" id="fake"
                 name="Fake MMR">
      <register access="RO" addr="0x00" id="decode_dummy">
        <info>The bit fields in this register are dummies with respect to address decoding.
They are used as bit slice defines within the VHDL top decoder section to
pick the proper address signals from the top level address bus (or VirtualBus)
For each I/O unit, a MMR_CFG_ entry is defined.
Later, these slice defines will be moved to the iomap definitions for the entire SoC
(see also memmap.xml for memory map)</info>

        <bitfield lsb="0" msb="6" name="MMR_CFG_fpga_registers"></bitfield>

        <bitfield lsb="0" msb="4" name="MMR_CFG_tap_registers"></bitfield>
      </register>
    </registermap>

    <registermap addrsize="16" endian="BIG" id="fpga_registers"
                 name="FPGA_Registers" offset="0x000">
      <register access="RO" addr="0x00" id="MagicId"></register>

      <register addr="0x02" id="Control">
        <info>Control register</info>

        <bitfield lsb="0" msb="0" name="ENABLE">
          <info>Enable FPGA engine</info>
        </bitfield>

        <bitfield lsb="1" msb="1" name="THROTTLE">
          <info>If set, slow down simulation</info>
        </bitfield>

        <bitfield lsb="6" msb="6" name="IRQ">
          <info>Virtual IRQ pin, H active</info>
        </bitfield>

        <bitfield lsb="7" msb="7" name="RESET">
          <info>RESET FPGA engine</info>
        </bitfield>
      </register>
    </registermap>

    <registermap addrsize="4" endian="BIG" id="tap_registers" name="TAP"
                 offset="0x0200">
      <register access="RO" addr="0x00" id="TAP_IDCODE" size="4">
        <info>IDCODE register. Contains IDCODE of attached CPU.</info>
      </register>

      <register access="RO" addr="0x04" id="TAP_EMUDATA" size="4">
        <info>EMUDATA register for data exchange between core/debug coprocessor and TAP</info>
      </register>

      <register addr="0x08" id="TAP_EMUCTRL" size="2">
        <info>Emulation control register. This is kept generic and CPU independent</info>

        <bitfield lsb="0" msb="0" name="EMUREQ">
          <info>Set this bit to request CPU to enter emulation</info>
        </bitfield>

        <bitfield lsb="4" msb="6" name="SELECT_REG">
          <info>CPU specific select field for emudata input. Used on TAPs which require multiplexing of the EMUDATA register.</info>
        </bitfield>

        <bitfield lsb="7" msb="7" name="EMUEXEC">
          <info>Some CPUs require the EMUEXEC bit to be toggled for executing an instruction. Refer to CPU debug reference section for details.</info>
        </bitfield>

        <bitfield lsb="15" msb="15" name="CORE_RESET">
          <info>Reset the CPU core.</info>
        </bitfield>

        <default>0xxxxxxx00000000</default>
      </register>

      <register access="RO" addr="0x0a" id="TAP_EMUSTAT" size="2">
        <info>Emulation status register. The LSB contains the TAP generic status bis, MSB contains CPU specific bits. Refer to the CPU debug register description for detailed information.</info>

        <bitfield lsb="0" msb="0" name="EMUACK">
          <info>Emulation acknowledge. When an emureq request has been issued, this bit turns 1 when it is acknowledged by the attached CPU. The EMUACK bit remains high on most implementations when the CPU is in emulation mode.</info>
        </bitfield>

        <bitfield lsb="1" msb="1" name="EMURDY">
          <info>Signal that emulation is ready. Poll this bit to see if emulation is busy.</info>
        </bitfield>

        <bitfield lsb="8" msb="15" name="CORE_SPEC">
          <info>Core specific status bits. See CPU debug reference.</info>
        </bitfield>
      </register>

      <register access="RW" addr="0x0c" id="TAP_EMUIR" size="4">
        <info>Emulation instruction register, 32 bit wide. This is used to feed instructions to the CPU core when in emulation mode.</info>
      </register>

      <register access="RO" addr="0x10" id="TAP_EMUPC" size="4">
        <info>Program counter of attached CPU. Only valid when in emulation. Might be unused on some CPU cores.</info>
      </register>

      <register access="RW" addr="0x18" id="TAP_SIMCTRL" size="1">
        <info>Simulation only control register for Virtual TAP.</info>

        <bitfield lsb="0" msb="0" name="SIM_THROTTLE">
          <info>Throttle simulation if this bit is set and when no TAP access occurs</info>
        </bitfield>

        <default>1</default>
      </register>
      <register addr="0x19" id="SIM_SLEEPCYCLES" size="2">
        <info>When Throttle bit set, simulation sleeps &lt;this register's value&gt;</info>
        <default>fa00</default>

      </register>
    </registermap>

    <group name="VirtualTap">
      <info>The VirtualTAP register set is a direct test access port implemented as virtual Bus in GHDLex.
It does not require any extra handshake logic.</info>

      <property name="EmuExec" type="BOOL">
        <info>Toggle this pin to execute command in EmuIR register</info>

        <regref bits="EMUEXEC" ref="TAP_EMUCTRL" />
      </property>

      <property name="EmuReq" type="BOOL">
        <info>Setting this bit H asserts the emulation request pin to the core</info>

        <regref bits="EMUREQ" ref="TAP_EMUCTRL" />
      </property>

      <property name="TapThrottle" type="BOOL">
        <info>Set 1 to throttle simulation</info>

        <regref bits="SIM_THROTTLE" ref="TAP_SIMCTRL" />
      </property>

      <property name="TapWaitCycles" type="INT">
        <info>Numer of cycles to wait</info>

        <regref ref="SIM_SLEEPCYCLES" />
      </property>

      <property access="RO" name="EmuReady" type="BOOL">
        <info>'1' when emulation ready</info>

        <regref bits="EMURDY" ref="TAP_EMUSTAT" />
      </property>

      <property access="RO" name="EmuAck" type="BOOL">
        <info>'1' when in emulation mode</info>

        <regref bits="EMUACK" ref="TAP_EMUSTAT" />
      </property>

      <property access="RO" name="EmuStat" type="REGISTER">
        <info>Emulation status register</info>

        <regref ref="TAP_EMUSTAT" />
      </property>

      <property name="EmuCtrl" type="REGISTER">
        <info>Emulation control register</info>

        <regref ref="TAP_EMUCTRL" />
      </property>

      <property name="EmuIR" type="REGISTER">
        <info>Instruction to execute on core on next EmuExec bit toggle</info>

        <regref ref="TAP_EMUIR" />
      </property>

      <property access="RO" name="EmuData" type="REGISTER">
        <info>Return emulation data from the core</info>

        <regref ref="TAP_EMUDATA" />
      </property>

      <property access="RO" name="EmuPC" type="REGISTER">
        <info>Current Program counter of core. Valid only when in emulation.</info>

        <regref ref="TAP_EMUPC" />
      </property>

      <property access="RO" name="IDCode" type="REGISTER">
        <info>The IDCODE of the core. Unique to every core architecture.</info>

        <regref ref="TAP_IDCODE" />
      </property>
    </group>

    <group name="VirtualPins">
      <property access="RW" name="Enable" type="BOOL">
        <info>Enable bit. Might be not used.</info>

        <regref bits="ENABLE" ref="Control" />
      </property>

      <property access="RW" name="Reset" type="BOOL">
        <info>External reset pin. High active.</info>

        <regref bits="RESET" ref="Control" />
      </property>

      <property access="RW" name="Timeout" type="INT">
        <info>Timeout value of FIFO in real microseconds</info>

        <variable>g_fifoconfig.timeout</variable>
      </property>

      <property access="RW" name="Retry" type="INT">
        <info>Number of retries after timeout</info>

        <variable>g_fifoconfig.retry</variable>
      </property>

      <property access="RW" name="Throttle" type="BOOL">
        <info>Throttle bit. Typically mapped to the global_throttle signal. If set, simulation will sleep (therefore run slower) while there is no FIFO activity</info>

        <regref bits="THROTTLE" ref="Control" />
      </property>

      <property access="RW" name="Irq" type="BOOL">
        <info>Simulates an IRQ pin. High active. Might not be implemented in all cores.</info>

        <regref bits="IRQ" ref="Control" />
      </property>
    </group>

    <group name="VirtualJTAG">
      <struct id="fifo" name="Fifo">
        <property access="RW" id="fifobuf" name="Buffer" type="BUFFER">
          <!--A buffer object that is handled via a handler function. See handler.c
(Function get_fifo()/set_fifo() for details.)-->

          <info>A FIFO buffer for communication between VHDL simulation and external software.</info>

          <handler type="DYNAMIC">fifo</handler>
        </property>

        <property access="RO" id="fifo_infill" name="InFill" type="INT">
          <handler type="DYNAMIC">fifo_infill</handler>
        </property>

        <property access="RO" id="fifo_outfill" name="OutFill" type="INT">
          <handler type="DYNAMIC">fifo_outfill</handler>
        </property>
      </struct>
    </group>
  </device>
</devdesc>
